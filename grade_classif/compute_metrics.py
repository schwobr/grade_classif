#AUTOGENERATED! DO NOT EDIT! File to edit: dev/_compute_metrics.ipynb (unless otherwise specified).

__all__ = ['norm', 'all_items', 'all_labels', 'ref', 'ref_means', 'ref_stds', 'i', 'scans', 'scan_names',
           'scan_indices', 'counts', 'alpha_means_base', 'beta_means_base', 'alpha_means', 'beta_means', 'alpha_stds',
           'beta_stds', 'ssims', 'rhos', 'bs', 'dl', 'alpha_means_base', 'alpha_means', 'beta_means', 'beta_means_base',
           'alpha_stds', 'beta_stds', 'ssims', 'rhos']

#Cell
from .params.parser import hparams
from .imports import *
from .models.plmodules import Normalizer
from .data.read import get_items
from .data.color import rgb_to_lab

#Cell
norm = Normalizer(hparams)

#Cell
all_items = norm.data.valid._ds.items
all_labels = norm.data.valid._ds.labels

#Cell
norm.load('6cacb7558df8464a843775ca6694ed3b')

#Cell
norm.freeze()

#Cell
ref = Path('/data/DeepLearning/SCHWOB_Robin/Patches_normacolor_1024/Patches_1024_1/CF_Normacolor_0182')

#Cell
ref_items, _ = get_items(ref, lambda x: x, extensions=['.png'])

#Cell
norm.data.valid._ds.items = ref_items
norm.data.valid._ds.labels = ref_items

#Cell
ref_means = torch.zeros(3, device=norm.main_device)
ref_stds = torch.zeros(3, device=norm.main_device)

#Cell
i = 0
for _, x in norm.val_dataloader()[0]:
    x = rgb_to_lab(x.to(norm.main_device))
    x[:, 0] = x[:, 0] / 100
    x[:, 1:] = (x[:, 1:] + 127) / 254
    ref_means += x.mean((0, 2, 3))
    ref_stds += x.std((0, 2, 3))
    i += 1
ref_means /= i
ref_stds /= i

#Cell
norm.data.valid._ds.items = all_items
norm.data.valid._ds.labels = all_labels

#Cell
scans = np.array(list(map(lambda x: x.parent.name, all_items)))

#Cell
scan_names = np.unique(scans)

#Cell
scan_indices = np.zeros(len(scans), dtype=np.int32)
counts = np.zeros(len(scan_names), dtype=np.int32)

#Cell
for i in range(len(scan_names)):
    t = scans == scan_names[i]
    scan_indices[t] = i
    counts[i] = t.sum()

#Cell
alpha_means_base = torch.zeros(len(scan_names), device=norm.main_device)
beta_means_base = torch.zeros(len(scan_names), device=norm.main_device)
alpha_means = torch.zeros(len(scan_names), device=norm.main_device)
beta_means = torch.zeros(len(scan_names), device=norm.main_device)
alpha_stds = torch.zeros(len(scan_names), device=norm.main_device)
beta_stds = torch.zeros(len(scan_names), device=norm.main_device)
ssims = torch.zeros(len(scan_names), device=norm.main_device)
rhos = torch.zeros(len(scan_names), device=norm.main_device)

#Cell
bs = norm.hparams.batch_size

#Cell
dl = norm.val_dataloader()[0]

#Cell
for k, (y, x) in tqdm(enumerate(dl), total=len(dl)):
    x = rgb_to_lab(x.to(norm.main_device))
    x[:, 0] = x[:, 0] / 100
    x[:, 1:] = (x[:, 1:] + 127) / 254
    y = rgb_to_lab(norm.predict(y.to(norm.main_device)))
    y[:, 0] = y[:, 0] / 100
    y[:, 1:] = (y[:, 1:] + 127) / 254
    idxs = scan_indices[bs*k: bs*(k+1)]
    mu_x = x.mean((2, 3))
    std_x = x.std((2, 3))
    mu_y = y.mean((2, 3))
    std_y = y.std((2, 3))
    mu_xy = (x*y).mean((2, 3))
    std_xy = mu_xy - mu_x*mu_y
    for idx in np.unique(idxs):
        t = idxs == idx
        alpha_means_base[idx] += mu_x[t, 1].sum(0)
        beta_means_base[idx] += mu_x[t, 2].sum(0)
        alpha_means[idx] += mu_y[t, 1].sum(0)
        beta_means[idx] += mu_y[t, 2].sum(0)
        alpha_stds[idx] += std_y[t, 1].sum(0)
        beta_stds[idx] += std_y[t, 2].sum(0)
        ssims[idx] += ((2*mu_x[t, 0]*mu_y[t, 0]+1e-2)*(2*std_xy[t, 0]+1e-2)/((mu_x[t, 0]**2+mu_y[t, 0]**2+1e-2)*(std_x[t, 0]**2+std_y[t, 0]**2+1e-2))).sum(0)
        rhos[idx] += (std_xy[t, 0]/(std_x[t, 0]*std_y[t, 0])).sum(0)

#Cell
alpha_means_base = alpha_means_base.cpu()
alpha_means = alpha_means.cpu()
beta_means = beta_means.cpu()
beta_means_base = beta_means_base.cpu()
alpha_stds = alpha_stds.cpu()
beta_stds = beta_stds.cpu()
ssims = ssims.cpu()
rhos = rhos.cpu()

#Cell
alpha_means_base /= counts
beta_means_base /= counts
alpha_means /= counts
beta_means /= counts
alpha_stds /= counts
beta_stds /= counts
ssims /= counts
rhos /= counts

#Cell
print(f'AMCE_a base : {torch.abs(alpha_means_base-ref_means[1]).mean()}')
print(f'AMCE_b base: {torch.abs(beta_means_base-ref_means[2]).mean()}')
print(f'AMCE_a : {torch.abs(alpha_means-ref_means[1]).mean()}')
print(f'AMCE_b : {torch.abs(beta_means-ref_means[2]).mean()}')
print(f'ADCE_a : {torch.abs(alpha_stds-ref_stds[1]).mean()}')
print(f'ADCE_b : {torch.abs(beta_stds-ref_stds[2]).mean()}')
print(f'MSSIM : {ssims.mean()}')
print(f'PCC : {rhos.mean()}')