#AUTOGENERATED! DO NOT EDIT! File to edit: dev/22_models.utils.ipynb (unless otherwise specified).

__all__ = ['named_leaf_modules', 'get_sizes', 'gaussian_mask', 'get_num_features']

#Cell
from ..core import ifnone
from .hooks import Hooks
from ..imports import *

#Cell
def named_leaf_modules(name, model):
    named_children = list(model.named_children())
    if named_children==[]:
        model.name = name
        return [model]
    else:
        res = []
        for n, m in named_children:
            pref = name+'.' if name != '' else ''
            res += named_leaf_modules(pref+n, m)
        return res

#Cell
def get_sizes(model, input_shape=(3, 224, 224), leaf_modules=None):
    leaf_modules = ifnone(leaf_modules, named_leaf_modules('', model))

    class Count:
        def __init__(self):
            self.k = 0
    count = Count()
    def _hook(model, input, output):
        model.k = count.k
        count.k += 1
        return model, output

    with Hooks(leaf_modules, _hook) as hooks:
        x = torch.rand(2, *input_shape)
        model.eval()(x)
        sizes = [hook.stored[1].shape for hook in hooks]
        mods = [hook.stored[0] for hook in hooks]
    idxs = np.argsort([mod.k for mod in mods])
    return np.array(sizes)[idxs], np.array(mods)[idxs]

#Cell
def gaussian_mask(m, s, d, R, C):
    # indices to create centres
    R = torch.arange(R, dtype=torch.float32).reshape((R, 1))
    C = torch.arange(C, dtype=torch.float32).reshape((1, C))
    centres = m + R * d
    column_centres = C - centres
    mask = torch.exp(-.5 * torch.square(column_centres / s))
    # we add eps for numerical stability
    normalised_mask = mask / (mask.sum(1, keepdims=True) + 1e-8)
    return normalised_mask

#Cell
def get_num_features(model):
    sizes, _ = get_sizes(model)
    return sizes[-1, 1]