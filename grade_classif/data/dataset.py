#AUTOGENERATED! DO NOT EDIT! File to edit: dev/12_data.dataset.ipynb (unless otherwise specified).

__all__ = ['TensorDataset', 'SplitDataset', 'MyDataset', 'ClassDataset', 'ImageClassifDataset', 'ImageSegmentDataset',
           'NormDataset']

#Cell
from .loaders import (
    ItemLoader,
    ImageLoader,
    MaskLoader,
    CategoryLoader,
)
from .utils import show_img, np_to_tensor
from .read import get_items
from .transforms import *
from ..core import ifnone
from ..imports import *
from albumentations import Compose, BasicTransform
from torch.utils.data import Dataset

#Cell
class TensorDataset(Dataset):
    """"""

    def __init__(
        self,
        ds: Dataset,
        tfms: Optional[Sequence[BasicTransform]] = None,
        tfm_y: bool = True,
    ):
        self._ds = ds
        self.tfms = ifnone(tfms, [])
        # for tfm_name in self._ds.item_loader.add_tfms:
        #    tfm = globals()[tfm_name]()
        #    self.tfms.append(tfm)
        self.tfm_y = tfm_y

    def __len__(self) -> int:
        return len(self._ds)

    def __getitem__(self, i: int) -> Tuple[torch.Tensor, torch.Tensor]:
        x, y = self._ds[i]
        if self.tfms != []:
            aug = Compose(self.tfms)
            augmented = aug(image=x, mask=y if self.tfm_y else None)
            x = augmented["image"]
            if self.tfm_y:
                y = augmented["mask"]
        x = np_to_tensor(
            x, type(self._ds.item_loader).__name__.lower().replace("loader", "")
        )
        y = np_to_tensor(
            y, type(self._ds.label_loader).__name__.lower().replace("loader", "")
        )
        return x, y

    def get_orig_tfmed(self, i: int) -> Tuple[torch.Tensor, torch.Tensor]:
        x, _ = self._ds[i]
        if self.tfms != []:
            aug = Compose(self.tfms)
            augmented = aug(image=x)
            x_tfmed = augmented["image"]
        else:
            x_tfmed = x
        return x, x_tfmed

    def __getattr__(self, name: str) -> Any:
        return getattr(self._ds, name)

#Cell
@dataclass
class SplitDataset:
    """"""

    train: Dataset
    valid: Dataset
    test: Dataset = None

    def to_tensor(
        self,
        tfms: Optional[Sequence[BasicTransform]] = None,
        tfm_y: bool = True,
        test_tfms: Optional[Sequence[BasicTransform]] = None,
    ) -> TensorDataset:
        """
        Transforms all datasets into `TensorDataset` objects
        """
        tfms = ifnone(tfms, (None, None))
        self.train = self.train.to_tensor(tfms=tfms[0], tfm_y=tfm_y)
        self.valid = self.valid.to_tensor(tfms=tfms[1], tfm_y=tfm_y)
        if self.test is not None:
            self.test = self.test.to_tensor(tfms=test_tfms, tfm_y=tfm_y)
        return self

#Cell
class MyDataset(Dataset):
    """"""

    def __init__(
        self,
        items: Sequence[Any],
        labels: Sequence[Any],
        item_loader: ItemLoader,
        label_loader: ItemLoader,
    ):
        super().__init__()
        self.items = np.array(items)
        self.labels = np.array(labels)
        self.item_loader = item_loader
        self.label_loader = label_loader

    def __len__(self) -> int:
        return len(self.items)

    def __getitem__(self, i: int) -> Tuple[Any, Any]:
        item, label = self.items[i], self.labels[i]
        x = self.item_loader(item)
        y = self.label_loader(label)
        return x, y

    @classmethod
    def from_folder(
        cls,
        folder: Path,
        label_func: Callable[[Path], Any],
        item_loader: ItemLoader,
        label_loader: ItemLoader,
        recurse: bool = True,
        extensions: Optional[Sequence[str]] = None,
        include: Optional[Sequence[str]] = None,
        exclude: Optional[Sequence[str]] = None,
        filterfunc: Optional[Callable[[Path], bool]] = None,
    ):
        """
        Creates a `MyDataset` object by reading files from a folder. It uses `get_item` and therefore works the same.
        """
        folder = Path(folder)
        items, labels = get_items(
            folder,
            label_func,
            recurse=recurse,
            extensions=extensions,
            include=include,
            exclude=exclude,
            filterfunc=None,
        )
        return cls(items, labels, item_loader, label_loader)

    def to_tensor(
        self, tfms: Optional[Sequence[BasicTransform]] = None, tfm_y: bool = True
    ) -> TensorDataset:
        """
        Creates a `TensorDataset` based on this dataset.
        """
        return TensorDataset(self, tfms=tfms, tfm_y=tfm_y)

    def split_by_list(
        self,
        train: Tuple[Sequence[Any], Sequence[Any]],
        valid: Tuple[Sequence[Any], Sequence[Any]],
        test: Optional[Tuple[Sequence[Any], Sequence[Any]]] = None,
    ) -> SplitDataset:
        """
        Creates a `SplitDataset` using `train`, `valid` and optionally `test` tuples. Each tuple contains 2 lists: one for items and one for labels.
        """
        return SplitDataset(
            self.__class__(train[0], train[1], self.item_loader, self.label_loader),
            self.__class__(valid[0], valid[1], self.item_loader, self.label_loader),
            None
            if test is None
            else self.__class__(test[0], test[1], self.item_loader, self.label_loader),
        )

    def split_by_folder(self) -> SplitDataset:
        """
        Creates a `SplitDataset` by looking for `Å§rain`, `valid` and `test` in item paths and splitting the dataset accordingly.
        """
        train = ([], [])
        valid = ([], [])
        test = ([], [])
        for item, label in zip(self.items, self.labels):
            if "train" in item.parts:
                train[0].append(item)
                train[1].append(label)
            elif "valid" in item.parts:
                valid[0].append(item)
                valid[1].append(label)
            elif "test" in item.parts:
                test[0].append(item)
                test[1].append(label)
        if test[0] == []:
            test = None
        return self.split_by_list(train, valid, test)

    def split_by_csv(
        self,
        csv: Union[Path, str],
        split_column: str = "split",
        id_column: str = "scan",
        get_id: Optional[Callable[[Any], Any]] = None,
    ) -> SplitDataset:
        """
        Creates a `SplitDataset` by using a csv that contains an `id_column` column for identifying items
        and a `split_column` column that contains either `'train'`, `'valid'` or `'test'`. `get_id` is the
        function used to extract the item's id from the item itself. By default it considers that `item` is a
        `Path` object and takes the parent folder's name as id.
        """
        get_id = ifnone(get_id, lambda x: x.parent.name)
        df = pd.read_csv(csv, header="infer")
        train = ([], [])
        valid = ([], [])
        test = ([], [])
        train_ids = df.loc[df[split_column] == "train", id_column]
        valid_ids = df.loc[df[split_column] == "valid", id_column]
        test_ids = df.loc[df[split_column] == "test", id_column]
        for item, label in zip(self.items, self.labels):
            item_id = get_id(item)
            if item_id in train_ids.values:
                train[0].append(item)
                train[1].append(label)
            elif item_id in valid_ids.values:
                valid[0].append(item)
                valid[1].append(label)
            elif item_id in test_ids.values:
                test[0].append(item)
                test[1].append(label)
        if test[0] == []:
            test = None
        return self.split_by_list(train, valid, test)

#Cell
class ClassDataset(MyDataset):
    def __init__(self, *args, n_classes: int = 2, **kwargs):
        super().__init__(*args, **kwargs)
        self.n_classes = n_classes

#Cell
class ImageClassifDataset(ClassDataset):
    def show(
        self,
        k: int,
        ax: Axes = None,
        figsize: Tuple[int, int] = (3, 3),
        hide_axis: bool = True,
        cmap: str = "viridis",
        **kwargs
    ):
        """
        Shows the `k`th image from the dataset with the corresponding label.
        """
        x, y = self[k]
        y = self.label_loader.classes[y]
        ax = show_img(
            x,
            ax=ax,
            hide_axis=hide_axis,
            cmap=cmap,
            figsize=figsize,
            title=str(y),
            **kwargs
        )

    def show_rand(
        self,
        ax: Axes = None,
        figsize: Tuple[int, int] = (3, 3),
        hide_axis: bool = True,
        cmap: str = "viridis",
        **kwargs
    ):
        """
        Shows a random image from the dataset with the corresponding label.
        """
        k = random.randint(0, len(self) - 1)
        self.show(k, ax=ax, figsize=figsize, hide_axis=hide_axis, cmap=cmap, **kwargs)

    @classmethod
    def from_folder(
        cls,
        folder: Union[str, Path],
        label_func: Callable[[Path], Any],
        n_classes: Optional[int] = None,
        classes: Optional[Sequence[Any]] = None,
        recurse: bool = True,
        extensions: Optional[Sequence[str]] = None,
        include: Optional[Sequence[str]] = None,
        exclude: Optional[Sequence[str]] = None,
        filterfunc: Optional[Callable[[Path], bool]] = None,
        **kwargs
    ):
        """
        Overwrites `MyDataset.from_folder`. Works basically the same but you don't need to pass loaders, but instead `n_classes`
        or `classes` arguments. Loaders are automatically created using these.
        """
        folder = Path(folder)
        items, labels = get_items(
            folder,
            label_func,
            recurse=recurse,
            extensions=extensions,
            include=include,
            exclude=exclude,
            filterfunc=filterfunc,
        )
        return cls(
            items,
            labels,
            ImageLoader(**kwargs),
            CategoryLoader(n_classes, classes),
            n_classes=ifnone(n_classes, len(classes)),
        )

#Cell
class ImageSegmentDataset(ClassDataset):
    def show(
        self,
        k: int,
        ax: Axes = None,
        figsize: Tuple[int, int] = (3, 3),
        title: Optional[str] = None,
        hide_axis: bool = True,
        cmap: str = "tab20",
        **kwargs
    ):
        """
        Shows the `k`th image from the dataset with the corresponding mask above it.
        """
        x, y = self[k]
        ax = show_img(
            x, ax=ax, hide_axis=hide_axis, cmap=cmap, figsize=figsize, **kwargs
        )
        ax = show_img(
            y,
            ax=ax,
            hide_axis=hide_axis,
            cmap=cmap,
            figsize=figsize,
            interpolation="nearest",
            alpha=alpha,
            vmin=0,
            title=title,
            **kwargs
        )

    def show_rand(
        self,
        ax: Axes = None,
        figsize: Tuple[int, int] = (3, 3),
        hide_axis: bool = True,
        cmap: str = "tab20",
        **kwargs
    ):
        """
        Shows a random image from the dataset withthe corresponding mask above it.
        """
        k = random.randint(0, len(self) - 1)
        self.show(k, ax=ax, figsize=figsize, hide_axis=hide_axis, cmap=cmap, **kwargs)

    @classmethod
    def from_folder(
        cls,
        folder: Union[Path, str],
        label_func: Callable[[Path], Path],
        n_classes: Optional[int] = None,
        classes: Optional[Any] = None,
        recurse: bool = True,
        extensions: Optional[Sequence[str]] = None,
        include: Optional[Sequence[str]] = None,
        exclude: Optional[Sequence[str]] = None,
        filterfunc: Optional[Callable[[Path], bool]] = None,
    ):
        """
        Same as `ImageClassifDataset.from_folder`.
        """
        folder = Path(folder)
        items, labels = get_items(
            folder,
            label_func,
            recurse=recurse,
            extensions=extensions,
            include=include,
            exclude=exclude,
            filterfunc=filtefunc,
        )
        return cls(
            items,
            labels,
            ImageLoader(),
            MaskLoader(),
            n_classes=ifnone(n_classes, len(classes)),
        )

#Cell
class NormDataset(MyDataset):
    def show(
        self,
        k: int,
        axs: Axes = None,
        figsize: Tuple[int, int] = (5, 5),
        title: Optional[str] = None,
        hide_axis: bool = True,
        cmap: str = "viridis",
        **kwargs
    ):
        """
        Shows the `k`th image from the dataset as grayscale and colored.
        """
        x, y = self[k]
        axs = ifnone(axs, plt.subplots(1, 2, figsize=figsize)[1])
        ax = show_img(
            x, ax=axs[0], hide_axis=hide_axis, cmap=cmap, figsize=figsize, **kwargs
        )
        ax = show_img(
            y, ax=axs[1], hide_axis=hide_axis, cmap=cmap, figsize=figsize, **kwargs
        )

    def show_rand(
        self,
        axs: Axes = None,
        figsize: Tuple[int, int] = (5, 5),
        hide_axis: bool = True,
        cmap: str = "viridis",
        **kwargs
    ):
        """
        Shows a random image from the dataset as grayscale and colored.
        """
        k = random.randint(0, len(self) - 1)
        self.show(k, axs=axs, figsize=figsize, hide_axis=hide_axis, cmap=cmap, **kwargs)

    @classmethod
    def from_folder(
        cls,
        folder: Union[Path, str],
        recurse: bool = True,
        extensions: Optional[Sequence[str]] = None,
        include: Optional[Sequence[str]] = None,
        exclude: Optional[Sequence[str]] = None,
        filterfunc: Optional[Callable[[Path], bool]] = None,
        **kwargs
    ):
        """
        Overwrites `MyDataset.from_folder` so that it doesn't need the loaders or a `label_func`.
        """

        def _label_func(x):
            return x

        folder = Path(folder)
        items, labels = get_items(
            folder,
            _label_func,
            recurse=recurse,
            extensions=extensions,
            include=include,
            exclude=exclude,
            filterfunc=filterfunc,
        )
        return cls(items, labels, ImageLoader(**kwargs), ImageLoader())